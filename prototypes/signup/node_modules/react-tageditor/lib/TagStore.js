"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = _interopRequireDefault(require("./utils"));

var _const = require("./const");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TagStore =
/*#__PURE__*/
function () {
  function TagStore(options) {
    _classCallCheck(this, TagStore);

    this.tags = [];
    this.options = options || {
      validate: function validate() {}
    };
    this._listeners = [];
  }

  _createClass(TagStore, [{
    key: "subscribe",
    value: function subscribe(fn) {
      this._listeners.push(fn);
    }
  }, {
    key: "broadcast",
    value: function broadcast() {
      this._listeners.forEach(function (fn) {
        fn();
      });
    }
  }, {
    key: "add",
    value: function add(text, cb) {
      var newTag = {
        id: _utils.default.uuid(),
        text: text
      };
      this.tags.push(newTag);
      cb && cb({}, newTag, this.tags.length - 1);
      this.broadcast();
    }
  }, {
    key: "index",
    value: function index(text) {
      var tagIndex = -1;

      for (var i = 0, l = this.tags.length; i < l; i++) {
        if (text === this.tags[i].text) {
          tagIndex = i;
          break;
        }
      }

      return tagIndex;
    }
  }, {
    key: "insertAfterTag",
    value: function insertAfterTag(tag, text, cb) {
      var tagIndex, newTag;
      this.tags.forEach(function (t, i) {
        if (t.id === tag.id) {
          tagIndex = i;
        }
      });

      if (tagIndex === void 0) {
        return;
      }

      newTag = {
        id: _utils.default.uuid(),
        text: text
      };
      this.tags.splice(tagIndex + 1, 0, newTag);
      cb && cb(null, newTag, tagIndex + 1);
    }
  }, {
    key: "validate",
    value: function validate(tagToSave, text) {
      // tags should
      // * be unique
      // * length > 0
      if (!text.length) {
        throw _utils.default.error(_const.ERROR.EMPTY, _const.ERROR_MSG[_const.ERROR.EMPTY]);
      }

      for (var i = 0, l = this.tags.length; i < l; i++) {
        var tag = this.tags[i];

        if (tag === tagToSave) {
          continue;
        }

        if (tag.text.trim() === text.trim()) {
          throw _utils.default.error(_const.ERROR.REPEAT, _const.ERROR_MSG[_const.ERROR.REPEAT]);
        }
      }

      this.options.validate(text, this.output());
    }
  }, {
    key: "save",
    value: function save(tagToSave, text, cb) {
      try {
        this.validate(tagToSave, text);
        this.tags.forEach(function (tag) {
          if (tag === tagToSave) {
            tag.text = text;
          }
        });
        cb && cb();
        this.broadcast();
      } catch (exception) {
        cb(exception);
      }
    }
  }, {
    key: "remove",
    value: function remove(tag) {
      var text = typeof tag === "string" ? tag : tag.text;
      this.tags = this.tags.filter(function (candidate) {
        return candidate.text !== text;
      });
      this.broadcast();
    }
  }, {
    key: "output",
    value: function output() {
      return this.tags.map(function (tag) {
        return tag.text;
      });
    }
  }]);

  return TagStore;
}();

var _default = TagStore;
exports.default = _default;